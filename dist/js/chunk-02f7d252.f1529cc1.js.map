{"version":3,"sources":["webpack:///./src/components/VideoPlayerList.vue?d988","webpack:///./node_modules/videojs-playlist/src/auto-advance.js","webpack:///./node_modules/videojs-playlist/src/play-item.js","webpack:///./node_modules/videojs-playlist/src/playlist-maker.js","webpack:///./src/assets/video/Lake.mp4","webpack:///./src/assets/video/Record.mp4","webpack:///./src/assets/video/Seoul.mp4","webpack:///./src/views/VideoJsList.vue?8598","webpack:///./src/components/VideoPlayerList.vue?9ee1","webpack:///src/components/VideoPlayerList.vue","webpack:///./src/components/VideoPlayerList.vue?230b","webpack:///./src/components/VideoPlayerList.vue","webpack:///src/views/VideoJsList.vue","webpack:///./src/views/VideoJsList.vue?07b7","webpack:///./src/views/VideoJsList.vue","webpack:///./src/assets/video/Sheep.mp4","webpack:///./src/views/VideoJsList.vue?d72c","webpack:///./src/assets/video/Animation.mp4","webpack:///./src/assets/video/Sand.mp4"],"names":["validSeconds","s","isNaN","Infinity","player","aa","playlist","autoadvance_","timeout","clearTimeout","trigger","off","setup","delay","cancelOnPlay","one","setTimeout","next","clearTracks","tracks","remoteTextTracks","i","length","removeRemoteTextTrack","playItem","item","replay","paused","ended","originalValue","playlistItemId_","currentPlaylistItemId_","poster","src","sources","ready","textTracks","forEach","addRemoteTextTrack","bind","playPromise","play","then","e","isItemObject","value","transformPrimitiveItems","arr","list","tempItem","Object","push","generatePlaylistItemId","guid","indexInPlaylistItemIds","currentItemId","sourceEquals","source1","source2","src1","src2","test","slice","indexOf","indexInSources","Array","isArray","j","source","randomize","index","lastIndex","rand","Math","floor","random","factory","initialList","initialIndex","changing","newList","newIndex","Error","previousPlaylist","nextPlaylist","filter","type","nextIndex","previousIndex","currentIndex_","currentItem","map","on","player_","repeat_","currentSrc","indexInItemIds","contains","currentIndex","current","min","max","first","newItem","last","previous","autoadvance","repeat","val","undefined","log","error","sort","compare","reverse","shuffle","rest","splice","concat","module","exports","render","_vm","this","_h","$createElement","_c","_self","attrs","videoOptions","listChange","_v","staticRenderFns","ref","staticClass","$event","onPlayerPlay","onPlayerPause","onPlayerEnded","onPlayerLoadeddata","onPlayerWaiting","onPlayerPlaying","onPlayerCanplay","onPlayerCanplaythrough","playerReadied","playerStateChanged","playerPlaylistchange","component","VBtn"],"mappings":"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","file":"js/chunk-02f7d252.f1529cc1.js","sourcesContent":["export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--6-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--6-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--6-oneOf-1-2!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./VideoPlayerList.vue?vue&type=style&index=0&lang=css&\"","\n/**\n * Validates a number of seconds to use as the auto-advance delay.\n *\n * @private\n * @param   {number} s\n *          The number to check\n *\n * @return  {boolean}\n *          Whether this is a valid second or not\n */\nconst validSeconds = s =>\n  typeof s === 'number' && !isNaN(s) && s >= 0 && s < Infinity;\n\n/**\n * Resets the auto-advance behavior of a player.\n *\n * @param {Player} player\n *        The player to reset the behavior on\n */\nlet reset = (player) => {\n  const aa = player.playlist.autoadvance_;\n\n  if (aa.timeout) {\n    player.clearTimeout(aa.timeout);\n  }\n\n  if (aa.trigger) {\n    player.off('ended', aa.trigger);\n  }\n\n  aa.timeout = null;\n  aa.trigger = null;\n};\n\n/**\n * Sets up auto-advance behavior on a player.\n *\n * @param  {Player} player\n *         the current player\n *\n * @param  {number} delay\n *         The number of seconds to wait before each auto-advance.\n *\n * @return {undefined}\n *         Used to short circuit function logic\n */\nconst setup = (player, delay) => {\n  reset(player);\n\n  // Before queuing up new auto-advance behavior, check if `seconds` was\n  // called with a valid value.\n  if (!validSeconds(delay)) {\n    player.playlist.autoadvance_.delay = null;\n    return;\n  }\n\n  player.playlist.autoadvance_.delay = delay;\n\n  player.playlist.autoadvance_.trigger = function() {\n\n    // This calls setup again, which will reset the existing auto-advance and\n    // set up another auto-advance for the next \"ended\" event.\n    const cancelOnPlay = () => setup(player, delay);\n\n    // If there is a \"play\" event while we're waiting for an auto-advance,\n    // we need to cancel the auto-advance. This could mean the user seeked\n    // back into the content or restarted the content. This is reproducible\n    // with an auto-advance > 0.\n    player.one('play', cancelOnPlay);\n\n    player.playlist.autoadvance_.timeout = player.setTimeout(() => {\n      reset(player);\n      player.off('play', cancelOnPlay);\n      player.playlist.next();\n    }, delay * 1000);\n  };\n\n  player.one('ended', player.playlist.autoadvance_.trigger);\n};\n\n/**\n * Used to change the reset function in this module at runtime\n * This should only be used in tests.\n *\n * @param {Function} fn\n *        The function to se the reset to\n */\nconst setReset_ = (fn) => {\n  reset = fn;\n};\n\nexport {\n  setReset_,\n  reset,\n  setup\n};\n","import {setup} from './auto-advance.js';\n\n/**\n * Removes all remote text tracks from a player.\n *\n * @param  {Player} player\n *         The player to clear tracks on\n */\nconst clearTracks = (player) => {\n  const tracks = player.remoteTextTracks();\n  let i = tracks && tracks.length || 0;\n\n  // This uses a `while` loop rather than `forEach` because the\n  // `TextTrackList` object is a live DOM list (not an array).\n  while (i--) {\n    player.removeRemoteTextTrack(tracks[i]);\n  }\n};\n\n/**\n * Plays an item on a player's playlist.\n *\n * @param  {Player} player\n *         The player to play the item on\n *\n * @param  {Object} item\n *         A source from the playlist.\n *\n * @return {Player}\n *         The player that is now playing the item\n */\nconst playItem = (player, item) => {\n  const replay = !player.paused() || player.ended();\n\n  player.trigger('beforeplaylistitem', item.originalValue || item);\n\n  if (item.playlistItemId_) {\n    player.playlist.currentPlaylistItemId_ = item.playlistItemId_;\n  }\n\n  player.poster(item.poster || '');\n  player.src(item.sources);\n  clearTracks(player);\n\n  player.ready(() => {\n\n    (item.textTracks || []).forEach(player.addRemoteTextTrack.bind(player));\n    player.trigger('playlistitem', item.originalValue || item);\n\n    if (replay) {\n      const playPromise = player.play();\n\n      // silence error when a pause interrupts a play request\n      // on browsers which return a promise\n      if (typeof playPromise !== 'undefined' && typeof playPromise.then === 'function') {\n        playPromise.then(null, (e) => {});\n      }\n    }\n\n    setup(player, player.playlist.autoadvance_.delay);\n  });\n\n  return player;\n};\n\nexport default playItem;\nexport {clearTracks};\n","import videojs from 'video.js';\nimport playItem from './play-item';\nimport * as autoadvance from './auto-advance';\n\n/**\n * Returns whether a playlist item is an object of any kind, excluding null.\n *\n * @private\n *\n * @param {Object}\n *         value to be checked\n *\n * @return {boolean}\n *          The result\n */\nconst isItemObject = (value) => {\n  return !!value && typeof value === 'object';\n};\n\n/**\n * Look through an array of playlist items and transform any primitive\n * as well as null values to objects. This method also adds a property\n * to the transformed item containing original value passed in an input list.\n *\n * @private\n *\n * @param  {Array} arr\n *         An array of playlist items\n *\n * @return {Array}\n *         A new array with transformed items\n */\nconst transformPrimitiveItems = (arr) => {\n  const list = [];\n  let tempItem;\n\n  arr.forEach(item => {\n    if (!isItemObject(item)) {\n      tempItem = Object(item);\n      tempItem.originalValue = item;\n    } else {\n      tempItem = item;\n    }\n\n    list.push(tempItem);\n  });\n\n  return list;\n};\n\n/**\n * Generate a unique id for each playlist item object. This id will be used to determine\n * index of an item in the playlist array for cases where there are multiple items with\n * the same source set.\n *\n * @private\n *\n * @param  {Array} arr\n *         An array of playlist items\n */\nconst generatePlaylistItemId = (arr) => {\n  let guid = 1;\n\n  arr.forEach(item => {\n    item.playlistItemId_ = guid++;\n  });\n};\n\n/**\n * Look through an array of playlist items for a specific playlist item id.\n *\n * @private\n * @param   {Array} list\n *          An array of playlist items to look through\n *\n * @param   {number} currentItemId\n *          The current item ID.\n *\n * @return  {number}\n *          The index of the playlist item or -1 if not found\n */\nconst indexInPlaylistItemIds = (list, currentItemId) => {\n  for (let i = 0; i < list.length; i++) {\n    if (list[i].playlistItemId_ === currentItemId) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n\n/**\n * Given two sources, check to see whether the two sources are equal.\n * If both source urls have a protocol, the protocols must match, otherwise, protocols\n * are ignored.\n *\n * @private\n * @param {string|Object} source1\n *        The first source\n *\n * @param {string|Object} source2\n *        The second source\n *\n * @return {boolean}\n *         The result\n */\nconst sourceEquals = (source1, source2) => {\n  let src1 = source1;\n  let src2 = source2;\n\n  if (typeof source1 === 'object') {\n    src1 = source1.src;\n  }\n  if (typeof source2 === 'object') {\n    src2 = source2.src;\n  }\n\n  if (/^\\/\\//.test(src1)) {\n    src2 = src2.slice(src2.indexOf('//'));\n  }\n  if (/^\\/\\//.test(src2)) {\n    src1 = src1.slice(src1.indexOf('//'));\n  }\n\n  return src1 === src2;\n};\n\n/**\n * Look through an array of playlist items for a specific `source`;\n * checking both the value of elements and the value of their `src`\n * property.\n *\n * @private\n * @param   {Array} arr\n *          An array of playlist items to look through\n *\n * @param   {string} src\n *          The source to look for\n *\n * @return  {number}\n *          The index of that source or -1\n */\nconst indexInSources = (arr, src) => {\n  for (let i = 0; i < arr.length; i++) {\n    const sources = arr[i].sources;\n\n    if (Array.isArray(sources)) {\n      for (let j = 0; j < sources.length; j++) {\n        const source = sources[j];\n\n        if (source && sourceEquals(source, src)) {\n          return i;\n        }\n      }\n    }\n  }\n\n  return -1;\n};\n\n/**\n * Randomize the contents of an array.\n *\n * @private\n * @param  {Array} arr\n *         An array.\n *\n * @return {Array}\n *         The same array that was passed in.\n */\nconst randomize = (arr) => {\n  let index = -1;\n  const lastIndex = arr.length - 1;\n\n  while (++index < arr.length) {\n    const rand = index + Math.floor(Math.random() * (lastIndex - index + 1));\n    const value = arr[rand];\n\n    arr[rand] = arr[index];\n    arr[index] = value;\n  }\n\n  return arr;\n};\n\n/**\n * Factory function for creating new playlist implementation on the given player.\n *\n * API summary:\n *\n * playlist(['a', 'b', 'c']) // setter\n * playlist() // getter\n * playlist.currentItem() // getter, 0\n * playlist.currentItem(1) // setter, 1\n * playlist.next() // 'c'\n * playlist.previous() // 'b'\n * playlist.first() // 'a'\n * playlist.last() // 'c'\n * playlist.autoadvance(5) // 5 second delay\n * playlist.autoadvance() // cancel autoadvance\n *\n * @param  {Player} player\n *         The current player\n *\n * @param  {Array=} initialList\n *         If given, an initial list of sources with which to populate\n *         the playlist.\n *\n * @param  {number=}  initialIndex\n *         If given, the index of the item in the list that should\n *         be loaded first. If -1, no video is loaded. If omitted, The\n *         the first video is loaded.\n *\n * @return {Function}\n *         Returns the playlist function specific to the given player.\n */\nexport default function factory(player, initialList, initialIndex = 0) {\n  let list = null;\n  let changing = false;\n\n  /**\n   * Get/set the playlist for a player.\n   *\n   * This function is added as an own property of the player and has its\n   * own methods which can be called to manipulate the internal state.\n   *\n   * @param  {Array} [newList]\n   *         If given, a new list of sources with which to populate the\n   *         playlist. Without this, the function acts as a getter.\n   *\n   * @param  {number}  [newIndex]\n   *         If given, the index of the item in the list that should\n   *         be loaded first. If -1, no video is loaded. If omitted, The\n   *         the first video is loaded.\n   *\n   * @return {Array}\n   *         The playlist\n   */\n  const playlist = player.playlist = (newList, newIndex = 0) => {\n    if (changing) {\n      throw new Error('do not call playlist() during a playlist change');\n    }\n\n    if (Array.isArray(newList)) {\n\n      // @todo - Simplify this to `list.slice()` for v5.\n      const previousPlaylist = Array.isArray(list) ? list.slice() : null;\n      const nextPlaylist = newList.slice();\n\n      list = nextPlaylist.slice();\n\n      // Transform any primitive and null values in an input list to objects\n      if (list.filter(item => isItemObject(item)).length !== list.length) {\n        list = transformPrimitiveItems(list);\n      }\n\n      // Add unique id to each playlist item. This id will be used\n      // to determine index in cases where there are more than one\n      // identical sources in the playlist.\n      generatePlaylistItemId(list);\n\n      // Mark the playlist as changing during the duringplaylistchange lifecycle.\n      changing = true;\n\n      player.trigger({\n        type: 'duringplaylistchange',\n        nextIndex: newIndex,\n        nextPlaylist,\n        previousIndex: playlist.currentIndex_,\n\n        // @todo - Simplify this to simply pass along `previousPlaylist` for v5.\n        previousPlaylist: previousPlaylist || []\n      });\n\n      changing = false;\n\n      if (newIndex !== -1) {\n        playlist.currentItem(newIndex);\n      }\n\n      // The only time the previous playlist is null is the first call to this\n      // function. This allows us to fire the `duringplaylistchange` event\n      // every time the playlist is populated and to maintain backward\n      // compatibility by not firing the `playlistchange` event on the initial\n      // population of the list.\n      //\n      // @todo - Remove this condition in preparation for v5.\n      if (previousPlaylist) {\n        player.setTimeout(() => {\n          player.trigger('playlistchange');\n        }, 0);\n      }\n    }\n\n    // Always return a shallow clone of the playlist list.\n    //  We also want to return originalValue if any item in the list has it.\n    return list.map((item) => item.originalValue || item).slice();\n  };\n\n  // On a new source, if there is no current item, disable auto-advance.\n  player.on('loadstart', () => {\n    if (playlist.currentItem() === -1) {\n      autoadvance.reset(player);\n    }\n  });\n\n  playlist.currentIndex_ = -1;\n  playlist.player_ = player;\n  playlist.autoadvance_ = {};\n  playlist.repeat_ = false;\n  playlist.currentPlaylistItemId_ = null;\n\n  /**\n   * Get or set the current item in the playlist.\n   *\n   * During the duringplaylistchange event, acts only as a getter.\n   *\n   * @param  {number} [index]\n   *         If given as a valid value, plays the playlist item at that index.\n   *\n   * @return {number}\n   *         The current item index.\n   */\n  playlist.currentItem = (index) => {\n    // If the playlist is changing, only act as a getter.\n    if (changing) {\n      return playlist.currentIndex_;\n    }\n\n    // Act as a setter when the index is given and is a valid number.\n    if (\n      typeof index === 'number' &&\n      playlist.currentIndex_ !== index &&\n      index >= 0 &&\n      index < list.length\n    ) {\n      playlist.currentIndex_ = index;\n      playItem(\n        playlist.player_,\n        list[playlist.currentIndex_]\n      );\n\n      return playlist.currentIndex_;\n    }\n\n    const src = playlist.player_.currentSrc() || '';\n\n    // If there is a currentPlaylistItemId_, validate that it matches the\n    // current source URL returned by the player. This is sufficient evidence\n    // to suggest that the source was set by the playlist plugin. This code\n    // exists primarily to deal with playlists where multiple items have the\n    // same source.\n    if (playlist.currentPlaylistItemId_) {\n      const indexInItemIds = indexInPlaylistItemIds(list, playlist.currentPlaylistItemId_);\n      const item = list[indexInItemIds];\n\n      // Found a match, this is our current index!\n      if (item && Array.isArray(item.sources) && indexInSources([item], src) > -1) {\n        playlist.currentIndex_ = indexInItemIds;\n        return playlist.currentIndex_;\n      }\n\n      // If this does not match the current source, null it out so subsequent\n      // calls can skip this step.\n      playlist.currentPlaylistItemId_ = null;\n    }\n\n    // Finally, if we don't have a valid, current playlist item ID, we can\n    // auto-detect it based on the player's current source URL.\n    playlist.currentIndex_ = playlist.indexOf(src);\n\n    return playlist.currentIndex_;\n  };\n\n  /**\n   * Checks if the playlist contains a value.\n   *\n   * @param  {string|Object|Array} value\n   *         The value to check\n   *\n   * @return {boolean}\n   *         The result\n   */\n  playlist.contains = (value) => {\n    return playlist.indexOf(value) !== -1;\n  };\n\n  /**\n   * Gets the index of a value in the playlist or -1 if not found.\n   *\n   * @param  {string|Object|Array} value\n   *         The value to find the index of\n   *\n   * @return {number}\n   *         The index or -1\n   */\n  playlist.indexOf = (value) => {\n    if (typeof value === 'string') {\n      return indexInSources(list, value);\n    }\n\n    const sources = Array.isArray(value) ? value : value.sources;\n\n    for (let i = 0; i < sources.length; i++) {\n      const source = sources[i];\n\n      if (typeof source === 'string') {\n        return indexInSources(list, source);\n      } else if (source.src) {\n        return indexInSources(list, source.src);\n      }\n    }\n\n    return -1;\n  };\n\n  /**\n   * Get the index of the current item in the playlist. This is identical to\n   * calling `currentItem()` with no arguments.\n   *\n   * @return {number}\n   *         The current item index.\n   */\n  playlist.currentIndex = () => playlist.currentItem();\n\n  /**\n   * Get the index of the last item in the playlist.\n   *\n   * @return {number}\n   *         The index of the last item in the playlist or -1 if there are no\n   *         items.\n   */\n  playlist.lastIndex = () => list.length - 1;\n\n  /**\n   * Get the index of the next item in the playlist.\n   *\n   * @return {number}\n   *         The index of the next item in the playlist or -1 if there is no\n   *         current item.\n   */\n  playlist.nextIndex = () => {\n    const current = playlist.currentItem();\n\n    if (current === -1) {\n      return -1;\n    }\n\n    const lastIndex = playlist.lastIndex();\n\n    // When repeating, loop back to the beginning on the last item.\n    if (playlist.repeat_ && current === lastIndex) {\n      return 0;\n    }\n\n    // Don't go past the end of the playlist.\n    return Math.min(current + 1, lastIndex);\n  };\n\n  /**\n   * Get the index of the previous item in the playlist.\n   *\n   * @return {number}\n   *         The index of the previous item in the playlist or -1 if there is\n   *         no current item.\n   */\n  playlist.previousIndex = () => {\n    const current = playlist.currentItem();\n\n    if (current === -1) {\n      return -1;\n    }\n\n    // When repeating, loop back to the end of the playlist.\n    if (playlist.repeat_ && current === 0) {\n      return playlist.lastIndex();\n    }\n\n    // Don't go past the beginning of the playlist.\n    return Math.max(current - 1, 0);\n  };\n\n  /**\n   * Plays the first item in the playlist.\n   *\n   * @return {Object|undefined}\n   *         Returns undefined and has no side effects if the list is empty.\n   */\n  playlist.first = () => {\n    if (changing) {\n      return;\n    }\n    const newItem = playlist.currentItem(0);\n\n    if (list.length) {\n      return list[newItem].originalValue || list[newItem];\n    }\n\n    playlist.currentIndex_ = -1;\n  };\n\n  /**\n   * Plays the last item in the playlist.\n   *\n   * @return {Object|undefined}\n   *         Returns undefined and has no side effects if the list is empty.\n   */\n  playlist.last = () => {\n    if (changing) {\n      return;\n    }\n    const newItem = playlist.currentItem(playlist.lastIndex());\n\n    if (list.length) {\n      return list[newItem].originalValue || list[newItem];\n    }\n\n    playlist.currentIndex_ = -1;\n  };\n\n  /**\n   * Plays the next item in the playlist.\n   *\n   * @return {Object|undefined}\n   *         Returns undefined and has no side effects if on last item.\n   */\n  playlist.next = () => {\n    if (changing) {\n      return;\n    }\n\n    const index = playlist.nextIndex();\n\n    if (index !== playlist.currentIndex_) {\n      const newItem = playlist.currentItem(index);\n\n      return list[newItem].originalValue || list[newItem];\n    }\n  };\n\n  /**\n   * Plays the previous item in the playlist.\n   *\n   * @return {Object|undefined}\n   *         Returns undefined and has no side effects if on first item.\n   */\n  playlist.previous = () => {\n    if (changing) {\n      return;\n    }\n\n    const index = playlist.previousIndex();\n\n    if (index !== playlist.currentIndex_) {\n      const newItem = playlist.currentItem(index);\n\n      return list[newItem].originalValue || list[newItem];\n    }\n  };\n\n  /**\n   * Set up auto-advance on the playlist.\n   *\n   * @param  {number} [delay]\n   *         The number of seconds to wait before each auto-advance.\n   */\n  playlist.autoadvance = (delay) => {\n    autoadvance.setup(playlist.player_, delay);\n  };\n\n  /**\n   * Sets `repeat` option, which makes the \"next\" video of the last video in\n   * the playlist be the first video in the playlist.\n   *\n   * @param  {boolean} [val]\n   *         The value to set repeat to\n   *\n   * @return {boolean}\n   *         The current value of repeat\n   */\n  playlist.repeat = (val) => {\n    if (val === undefined) {\n      return playlist.repeat_;\n    }\n\n    if (typeof val !== 'boolean') {\n      videojs.log.error('videojs-playlist: Invalid value for repeat', val);\n      return;\n    }\n\n    playlist.repeat_ = !!val;\n    return playlist.repeat_;\n  };\n\n  /**\n   * Sorts the playlist array.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort}\n   * @fires playlistsorted\n   *\n   * @param {Function} compare\n   *        A comparator function as per the native Array method.\n   */\n  playlist.sort = (compare) => {\n\n    // Bail if the array is empty.\n    if (!list.length) {\n      return;\n    }\n\n    list.sort(compare);\n\n    // If the playlist is changing, don't trigger events.\n    if (changing) {\n      return;\n    }\n\n    /**\n     * Triggered after the playlist is sorted internally.\n     *\n     * @event playlistsorted\n     * @type {Object}\n     */\n    player.trigger('playlistsorted');\n  };\n\n  /**\n   * Reverses the playlist array.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse}\n   * @fires playlistsorted\n   */\n  playlist.reverse = () => {\n\n    // Bail if the array is empty.\n    if (!list.length) {\n      return;\n    }\n\n    list.reverse();\n\n    // If the playlist is changing, don't trigger events.\n    if (changing) {\n      return;\n    }\n\n    /**\n     * Triggered after the playlist is sorted internally.\n     *\n     * @event playlistsorted\n     * @type {Object}\n     */\n    player.trigger('playlistsorted');\n  };\n\n  /**\n   * Shuffle the contents of the list randomly.\n   *\n   * @see   {@link https://github.com/lodash/lodash/blob/40e096b6d5291a025e365a0f4c010d9a0efb9a69/shuffle.js}\n   * @fires playlistsorted\n   * @todo  Make the `rest` option default to `true` in v5.0.0.\n   * @param {Object} [options]\n   *        An object containing shuffle options.\n   *\n   * @param {boolean} [options.rest = false]\n   *        By default, the entire playlist is randomized. However, this may\n   *        not be desirable in all cases, such as when a user is already\n   *        watching a video.\n   *\n   *        When `true` is passed for this option, it will only shuffle\n   *        playlist items after the current item. For example, when on the\n   *        first item, will shuffle the second item and beyond.\n   */\n  playlist.shuffle = ({rest} = {}) => {\n    let index = 0;\n    let arr = list;\n\n    // When options.rest is true, start randomization at the item after the\n    // current item.\n    if (rest) {\n      index = playlist.currentIndex_ + 1;\n      arr = list.slice(index);\n    }\n\n    // Bail if the array is empty or too short to shuffle.\n    if (arr.length <= 1) {\n      return;\n    }\n\n    randomize(arr);\n\n    // When options.rest is true, splice the randomized sub-array back into\n    // the original array.\n    if (rest) {\n      list.splice(...[index, arr.length].concat(arr));\n    }\n\n    // If the playlist is changing, don't trigger events.\n    if (changing) {\n      return;\n    }\n\n    /**\n     * Triggered after the playlist is sorted internally.\n     *\n     * @event playlistsorted\n     * @type {Object}\n     */\n    player.trigger('playlistsorted');\n  };\n\n  // If an initial list was given, populate the playlist with it.\n  if (Array.isArray(initialList)) {\n    playlist(initialList.slice(), initialIndex);\n\n  // If there is no initial list given, silently set an empty array.\n  } else {\n    list = [];\n  }\n\n  return playlist;\n}\n","module.exports = __webpack_public_path__ + \"media/Lake.de4ee309.mp4\";","module.exports = __webpack_public_path__ + \"media/Record.6ca01500.mp4\";","module.exports = __webpack_public_path__ + \"media/Seoul.dc4603c9.mp4\";","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('video-player-list',{attrs:{\"options\":_vm.videoOptions,\"listOptions\":_vm.playlist}}),_c('div',[_c('v-btn',{on:{\"click\":_vm.listChange}},[_vm._v(\" list 변경 \")])],1)],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('video',{ref:\"videoPlayerList\",staticClass:\"video-js\",attrs:{\"playsinline\":true},on:{\"play\":function($event){return _vm.onPlayerPlay($event)},\"pause\":function($event){return _vm.onPlayerPause($event)},\"ended\":function($event){return _vm.onPlayerEnded($event)},\"loadeddata\":function($event){return _vm.onPlayerLoadeddata($event)},\"waiting\":function($event){return _vm.onPlayerWaiting($event)},\"playing\":function($event){return _vm.onPlayerPlaying($event)},\"canplay\":function($event){return _vm.onPlayerCanplay($event)},\"canplaythrough\":function($event){return _vm.onPlayerCanplaythrough($event)},\"ready\":_vm.playerReadied,\"statechanged\":function($event){return _vm.playerStateChanged($event)},\"playlistchange\":function($event){return _vm.playerPlaylistchange($event)}}})])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\r\n    <div>\r\n        <video ref=\"videoPlayerList\" class=\"video-js\"\r\n                    :playsinline=\"true\"\r\n                    @play=\"onPlayerPlay($event)\"\r\n                    @pause=\"onPlayerPause($event)\"\r\n                    @ended=\"onPlayerEnded($event)\"\r\n                    @loadeddata=\"onPlayerLoadeddata($event)\"\r\n                    @waiting=\"onPlayerWaiting($event)\"\r\n                    @playing=\"onPlayerPlaying($event)\"\r\n                    @canplay=\"onPlayerCanplay($event)\"\r\n                    @canplaythrough=\"onPlayerCanplaythrough($event)\"\r\n                    @ready=\"playerReadied\"\r\n                    @statechanged=\"playerStateChanged($event)\"\r\n                    @playlistchange=\"playerPlaylistchange($event)\">\r\n        </video>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\nimport videojs from 'video.js'\r\nimport playlistMaker from \"videojs-playlist/src/playlist-maker\"\r\nimport 'video.js/dist/video-js.css'\r\n\r\n\r\nconst plugin = function(list, item) {\r\n  playlistMaker(this, list, item);\r\n};\r\n\r\nvideojs.registerPlugin('playlist', plugin);\r\n\r\n\r\nexport default {\r\n    name: \"VideoPlayerList\",\r\n    props: {\r\n        options: {\r\n            type: Object,\r\n            default() {\r\n                return {};\r\n            }\r\n        },\r\n        listOptions: {\r\n            type: Array,\r\n            default() {\r\n                return {};\r\n            }\r\n        }\r\n    },\r\n    data() {\r\n        return {\r\n            player: null\r\n        }\r\n    },\r\n    mounted() {\r\n        this.player = videojs(this.$refs.videoPlayerList, this.options, function onPlayerReady() {\r\n            console.log('onPlayerReady', this);\r\n        })\r\n        // Play through the playlist automatically.    \r\n\t\tthis.player.playlist(this.listOptions);\r\n        this.player.playlist.autoadvance(0);\r\n        this.player.playlist.repeat(false);\r\n        this.player.muted(false);\r\n    },\r\n    beforeDestroy() {\r\n        if (this.player) {\r\n            this.player.dispose()\r\n        }\r\n    },\r\n    methods: {\r\n      // listen event\r\n      onPlayerPlay(player) {\r\n            console.log('player play!', player)\r\n      },\r\n      onPlayerPause(player) {\r\n            console.log('player pause!', player)\r\n      },\r\n      onPlayerEnded(player) {\r\n            console.log('player ended!', player)\r\n      },\r\n      onPlayerLoadeddata(player) {\r\n            console.log('player Loadeddata!', player)\r\n      },\r\n      onPlayerWaiting(player) {\r\n            console.log('player Waiting!', player)\r\n      },\r\n      onPlayerPlaying(player) {\r\n            console.log('player Playing!', player)\r\n      },\r\n      /*\r\n      @timeupdate=\"onPlayerTimeupdate($event)\"     \r\n      onPlayerTimeupdate(player) {\r\n            console.log('player Timeupdate!', player.currentTime())\r\n      },\r\n      */      \r\n      onPlayerCanplay(player) {\r\n            console.log('player Canplay!', player)\r\n      },\r\n      onPlayerCanplaythrough(player) {\r\n            console.log('player Canplaythrough!', player)\r\n      },\r\n      // or listen state event\r\n      playerStateChanged(playerCurrentState) {\r\n            console.log('player current update state', playerCurrentState)\r\n      },\r\n      // player is ready\r\n      playerReadied(player) {\r\n        // seek to 10s\r\n        console.log('example player 1 readied', player)\r\n        //player.currentTime(10)\r\n        console.log('example 01: the player is readied', player)\r\n      },\r\n      playerPlaylistchange(player){\r\n          console.log('player Playlistchange!', player)\r\n      }      \r\n      \r\n    },\r\n}\r\n\r\n</script>\r\n<style>\r\n@import '../assets/css/video-js.css';\r\n</style>","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./VideoPlayerList.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./VideoPlayerList.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./VideoPlayerList.vue?vue&type=template&id=f8304e92&\"\nimport script from \"./VideoPlayerList.vue?vue&type=script&lang=js&\"\nexport * from \"./VideoPlayerList.vue?vue&type=script&lang=js&\"\nimport style0 from \"./VideoPlayerList.vue?vue&type=style&index=0&lang=css&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","<template>\r\n  <div>\r\n    <video-player-list :options=\"videoOptions\"\r\n                       :listOptions=\"playlist\"/>\r\n\r\n    <div>\r\n    <v-btn\r\n        @click=\"listChange\"\r\n    >\r\n        list 변경\r\n    </v-btn>    \r\n    </div>                   \r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport VideoPlayerList from '@/components/VideoPlayerList.vue'\r\n//import 'video.js/dist/video-js.css'\r\nexport default {\r\n\tname: 'videoJsList',\r\n\tcomponents: {\r\n\t\tVideoPlayerList\r\n\t},\r\n\tdata() {\r\n\t\treturn {\r\n\t\t\tvideoOptions: {\r\n\t\t\t\tautoplay: false,\r\n\t\t\t\tcontrols: true,\r\n                plugins: {\r\n                    playlist: {\r\n                        autoadvance: true\r\n                    }\r\n                },                \r\n\t\t\t},\r\n            playlist: [{\r\n                sources: [{\r\n                            src: require('@/assets/video/Animation.mp4'),\r\n                            type: 'video/mp4'\r\n                        }],\r\n                    }, {\r\n                sources: [{\r\n                            src: require('@/assets/video/Seoul.mp4'),\r\n                            type: 'video/mp4'\r\n                        }],\r\n                    }, {\r\n                sources: [{\r\n                            src: require('@/assets/video/Lake.mp4'),\r\n                            type: 'video/mp4'\r\n                        }],\r\n                    }, {\r\n                sources: [{\r\n                            src: require('@/assets/video/Record.mp4'),\r\n                            type: 'video/mp4'\r\n                        }],\r\n                    }, {\r\n                sources: [{\r\n                            src: require('@/assets/video/Sand.mp4'),\r\n                            type: 'video/mp4'\r\n                        }],\r\n                    }, {\r\n                sources: [{\r\n                            src: require('@/assets/video/Sheep.mp4'),\r\n                            type: 'video/mp4'\r\n                        }],\r\n                }],\r\n\r\n            changePlaylist: [{\r\n                sources: [{\r\n                            src: require('@/assets/video/Sheep.mp4'),\r\n                            type: 'video/mp4'\r\n                        }],\r\n                }],\r\n\r\n\t\t};\r\n\t},\r\n    methods: {\r\n        listChange(){\r\n            console.log('listChange')\r\n\r\n            this.playlist=this.changePlaylist\r\n        }\r\n    }\r\n}\r\n\r\n</script>\r\n<style>\r\n@import '../assets/css/video-js.css';\r\n</style>","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./VideoJsList.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./VideoJsList.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./VideoJsList.vue?vue&type=template&id=aad53a5a&\"\nimport script from \"./VideoJsList.vue?vue&type=script&lang=js&\"\nexport * from \"./VideoJsList.vue?vue&type=script&lang=js&\"\nimport style0 from \"./VideoJsList.vue?vue&type=style&index=0&lang=css&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports\n\n/* vuetify-loader */\nimport installComponents from \"!../../node_modules/vuetify-loader/lib/runtime/installComponents.js\"\nimport { VBtn } from 'vuetify/lib/components/VBtn';\ninstallComponents(component, {VBtn})\n","module.exports = __webpack_public_path__ + \"media/Sheep.2fceb2c9.mp4\";","export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--6-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--6-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--6-oneOf-1-2!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./VideoJsList.vue?vue&type=style&index=0&lang=css&\"","module.exports = __webpack_public_path__ + \"media/Animation.ec4aed1b.mp4\";","module.exports = __webpack_public_path__ + \"media/Sand.17ed6f13.mp4\";"],"sourceRoot":""}